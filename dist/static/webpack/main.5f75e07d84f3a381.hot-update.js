"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nvar _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js */ \"./node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _asyncToGenerator = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\n\nfunction _export(target, all) {\n  for (var name in all) {\n    Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n}\n\n_export(exports, {\n  \"default\": function _default() {\n    return Router;\n  },\n  matchesMiddleware: function matchesMiddleware() {\n    return _matchesMiddleware;\n  },\n  createKey: function createKey() {\n    return _createKey;\n  }\n});\n\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\n\nvar _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\n\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\n\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\n\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\n\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\n\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\n\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\n\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\n\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\n\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\n\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\n\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\n\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\n\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\n\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\n\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\n\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\n\nfunction _matchesMiddleware(_x) {\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction _matchesMiddleware2() {\n  _matchesMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(options) {\n    var matchers, _ref6, asPathname, cleanedAs, asWithBasePathAndLocale;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return Promise.resolve(options.router.pageLoader.getMiddleware());\n\n          case 2:\n            matchers = _context8.sent;\n\n            if (matchers) {\n              _context8.next = 5;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", false);\n\n          case 5:\n            _ref6 = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref6.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n\n            cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n            asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n            // where we can access more info such as headers, HttpOnly cookie, etc.\n\n            return _context8.abrupt(\"return\", matchers.some(function (m) {\n              return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n            }));\n\n          case 9:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _ref = (0, _resolvehref.resolveHref)(router, url, true),\n      _ref2 = _slicedToArray(_ref, 2),\n      resolvedHref = _ref2[0],\n      resolvedAs = _ref2[1];\n\n  var origin = (0, _utils.getLocationOrigin)();\n  var hrefWasAbsolute = resolvedHref.startsWith(origin);\n  var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  var matchedPath = response.headers.get(\"x-matched-path\");\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || undefined) {\n      var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(function (param) {\n        var _param = _slicedToArray(param, 2),\n            pages = _param[0],\n            rewrites = _param[1].__rewrites;\n\n        var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            nextConfig:  false ? 0 : nextConfig,\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (false) { var result; } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsepath.parsePath)(source);\n    var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    })), {}, {\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    }));\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n\n  var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      var _src = (0, _parsepath.parsePath)(redirectTarget);\n\n      var _pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      })), {}, {\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      }));\n\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + _pathname + _src.query + _src.hash,\n        newUrl: \"\" + _pathname + _src.query + _src.hash\n      });\n    }\n\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\n\nfunction withMiddlewareEffects(_x2) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(options) {\n    var matches, data, effect;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return _matchesMiddleware(options);\n\n          case 2:\n            matches = _context9.sent;\n\n            if (!(!matches || !options.fetchData)) {\n              _context9.next = 5;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", null);\n\n          case 5:\n            _context9.prev = 5;\n            _context9.next = 8;\n            return options.fetchData();\n\n          case 8:\n            data = _context9.sent;\n            _context9.next = 11;\n            return getMiddlewareData(data.dataHref, data.response, options);\n\n          case 11:\n            effect = _context9.sent;\n            return _context9.abrupt(\"return\", {\n              dataHref: data.dataHref,\n              json: data.json,\n              response: data.response,\n              text: data.text,\n              cacheKey: data.cacheKey,\n              effect: effect\n            });\n\n          case 15:\n            _context9.prev = 15;\n            _context9.t0 = _context9[\"catch\"](5);\n            return _context9.abrupt(\"return\", null);\n\n          case 18:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[5, 15]]);\n  }));\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction fetchNextData(param) {\n  var dataHref = param.dataHref,\n      inflightCache = param.inflightCache,\n      isPrefetch = param.isPrefetch,\n      hasMiddleware = param.hasMiddleware,\n      isServerRender = param.isServerRender,\n      parseJSON = param.parseJSON,\n      persistCache = param.persistCache,\n      isBackground = param.isBackground,\n      unstable_skipClientCache = param.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var _params_method;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: \"prefetch\"\n      } : {}, isPrefetch && hasMiddleware ? {\n        \"x-middleware-prefetch\": \"1\"\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: \"\",\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    })[\"catch\"](function (err) {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n\n      if ( // chrome\n      err.message === \"Failed to fetch\" || // firefox\n      err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n      err.message === \"Load failed\") {\n        (0, _routeloader.markAssetError)(err);\n      }\n\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\n\nfunction _createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(param) {\n  var url = param.url,\n      router = param.router; // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(param) {\n  var route = param.route,\n      router = param.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref3) {\n    var _this = this;\n\n    var initialProps = _ref3.initialProps,\n        pageLoader = _ref3.pageLoader,\n        App = _ref3.App,\n        wrapApp = _ref3.wrapApp,\n        Component = _ref3.Component,\n        err = _ref3.err,\n        subscription = _ref3.subscription,\n        isFallback = _ref3.isFallback,\n        locale = _ref3.locale,\n        locales = _ref3.locales,\n        defaultLocale = _ref3.defaultLocale,\n        domainLocales = _ref3.domainLocales,\n        isPreview = _ref3.isPreview;\n\n    _classCallCheck(this, Router);\n\n    // Server Data Cache (full data requests)\n    this.sdc = {}; // Server Background Cache (HEAD requests)\n\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = _createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n      _this.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this.pathname,\n            _query = _this.query;\n\n        _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(_pathname2),\n          query: _query\n        }), (0, _utils.getURL)());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (false) { var v; }\n\n      _this._key = key;\n\n      var _ref4 = (0, _parserelativeurl.parseRelativeUrl)(url),\n          pathname = _ref4.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this.isSsr && as === (0, _addbasepath.addBasePath)(_this.asPath) && pathname === (0, _addbasepath.addBasePath)(_this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this._bps && !_this._bps(state)) {\n        return;\n      }\n\n      _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this._shallow,\n        locale: options.locale || _this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removetrailingslash.removeTrailingSlash)(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n\n    if (true) {\n      var _require = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter/index.js\"),\n          BloomFilter = _require.BloomFilter;\n\n      var staticFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n      var dynamicFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n\n      if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n\n        this._bfl_s[\"import\"](staticFilterData);\n      }\n\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n\n        this._bfl_d[\"import\"](dynamicFilterData);\n      }\n    } // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath =  false || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n\n    if (false) {}\n\n    this.state = {\n      route: route,\n      pathname: pathname,\n      query: query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = _matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as !== pathname;\n\n          _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query: query\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener(\"popstate\", this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Go forward in history\n    */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      window.history.forward();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as, options) {\n      if (options === void 0) options = {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change(\"pushState\", url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as, options) {\n      if (options === void 0) options = {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change(\"replaceState\", url, as, options);\n    }\n  }, {\n    key: \"_bfl\",\n    value: function () {\n      var _bfl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(as, resolvedAs, locale, skipNavigate) {\n        var matchesBflStatic, matchesBflDynamic, _i, _arr, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i2, _arr2, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (false) {}\n\n                matchesBflStatic = false;\n                matchesBflDynamic = false;\n                _i = 0, _arr = [as, resolvedAs];\n\n              case 4:\n                if (!(_i < _arr.length)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                curAs = _arr[_i];\n\n                if (!curAs) {\n                  _context.next = 32;\n                  break;\n                }\n\n                asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n\n                if (!(asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname))) {\n                  _context.next = 32;\n                  break;\n                }\n\n                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.has(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.has(asNoSlashLocale));\n                _i2 = 0, _arr2 = [asNoSlash, asNoSlashLocale];\n\n              case 12:\n                if (!(_i2 < _arr2.length)) {\n                  _context.next = 27;\n                  break;\n                }\n\n                normalizedAS = _arr2[_i2];\n                // if any sub-path of as matches a dynamic filter path\n                // it should be hard navigated\n                curAsParts = normalizedAS.split(\"/\");\n                i = 0;\n\n              case 16:\n                if (!(!matchesBflDynamic && i < curAsParts.length + 1)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                currentPart = curAsParts.slice(0, i).join(\"/\");\n\n                if (!(currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.has(currentPart)))) {\n                  _context.next = 21;\n                  break;\n                }\n\n                matchesBflDynamic = true;\n                return _context.abrupt(\"break\", 24);\n\n              case 21:\n                i++;\n                _context.next = 16;\n                break;\n\n              case 24:\n                _i2++;\n                _context.next = 12;\n                break;\n\n              case 27:\n                if (!(matchesBflStatic || matchesBflDynamic)) {\n                  _context.next = 32;\n                  break;\n                }\n\n                if (!skipNavigate) {\n                  _context.next = 30;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", true);\n\n              case 30:\n                handleHardNavigation({\n                  url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                  router: this\n                });\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 32:\n                _i++;\n                _context.next = 4;\n                break;\n\n              case 35:\n                return _context.abrupt(\"return\", false);\n\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _bfl(_x3, _x4, _x5, _x6) {\n        return _bfl2.apply(this, arguments);\n      }\n\n      return _bfl;\n    }()\n  }, {\n    key: \"change\",\n    value: function () {\n      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(method, url, as, options, forcedScroll) {\n        var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, rewritesResult, routeMatch, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, _routeInfo_route, isValidShallowRoute, _options_scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, canSkipUpdating, hashRegex;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if ((0, _islocalurl.isLocalURL)(url)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: url,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 3:\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n                isQueryUpdating = options._h === 1;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this._bfl(as, undefined, options.locale);\n\n              case 7:\n                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                nextState = _objectSpread({}, this.state); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n                // or a navigation has occurred\n\n                readyStateChange = this.isReady !== true;\n                this.isReady = true;\n                isSsr = this.isSsr;\n\n                if (!isQueryUpdating) {\n                  this.isSsr = false;\n                } // if a route transition is already in progress before\n                // the query updating is triggered ignore query updating\n\n\n                if (!(isQueryUpdating && this.clc)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 15:\n                prevLocale = nextState.locale;\n\n                if (true) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n                if (typeof options.locale === \"undefined\") {\n                  options.locale = nextState.locale;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n                localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n\n                if (localePathResult.detectedLocale) {\n                  nextState.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                  as = (0, _formaturl.formatWithValidation)(parsedAs);\n                  url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n                }\n\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                if (!didNavigate) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 28:\n                // marking route changes as a navigation start entry\n                if (_utils.ST) {\n                  performance.mark(\"routeChange\");\n                }\n\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n                routeProps = {\n                  shallow: shallow\n                };\n\n                if (this._inFlightRoute && this.clc) {\n                  if (!isSsr) {\n                    Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n                  }\n\n                  this.clc();\n                  this.clc = null;\n                }\n\n                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                this._inFlightRoute = as;\n                localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n\n                if (!(!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context2.next = 52;\n                  break;\n                }\n\n                nextState.asPath = cleanedAs;\n                Router.events.emit(\"hashChangeStart\", as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n                this.changeState(method, url, as, _objectSpread(_objectSpread({}, options), {}, {\n                  scroll: false\n                }));\n\n                if (scroll) {\n                  this.scrollToHash(cleanedAs);\n                }\n\n                _context2.prev = 41;\n                _context2.next = 44;\n                return this.set(nextState, this.components[nextState.route], null);\n\n              case 44:\n                _context2.next = 50;\n                break;\n\n              case 46:\n                _context2.prev = 46;\n                _context2.t0 = _context2[\"catch\"](41);\n\n                if ((0, _iserror[\"default\"])(_context2.t0) && _context2.t0.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t0, cleanedAs, routeProps);\n                }\n\n                throw _context2.t0;\n\n              case 50:\n                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                return _context2.abrupt(\"return\", true);\n\n              case 52:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                pathname = parsed.pathname, query = parsed.query; // if we detected the path as app route during prefetching\n                // trigger hard navigation\n\n                if (!((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter)) {\n                  _context2.next = 57;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 57:\n                _context2.prev = 57;\n                _context2.next = 60;\n                return Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n\n              case 60:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context2.next = 70;\n                break;\n\n              case 66:\n                _context2.prev = 66;\n                _context2.t1 = _context2[\"catch\"](57);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 70:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = \"replaceState\";\n                } // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n\n\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n\n                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname))); // we don't attempt resolve asPath when we need to execute\n                // middleware as the resolving will occur server-side\n\n                _context2.t2 = !options.shallow;\n\n                if (!_context2.t2) {\n                  _context2.next = 81;\n                  break;\n                }\n\n                _context2.next = 80;\n                return _matchesMiddleware({\n                  asPath: as,\n                  locale: nextState.locale,\n                  router: this\n                });\n\n              case 80:\n                _context2.t2 = _context2.sent;\n\n              case 81:\n                isMiddlewareMatch = _context2.t2;\n\n                if (isQueryUpdating && isMiddlewareMatch) {\n                  shouldResolveHref = false;\n                }\n\n                if (!(shouldResolveHref && pathname !== \"/_error\")) {\n                  _context2.next = 96;\n                  break;\n                }\n\n                options._shouldResolveHref = true;\n\n                if (true) {\n                  _context2.next = 94;\n                  break;\n                }\n\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context2.next = 90;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", true);\n\n              case 90:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = rewritesResult.asPath;\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                _context2.next = 96;\n                break;\n\n              case 94:\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 96:\n                if ((0, _islocalurl.isLocalURL)(as)) {\n                  _context2.next = 101;\n                  break;\n                }\n\n                if (false) {}\n\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n              case 99:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 101:\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                routeMatch = false;\n\n                if (!(0, _isdynamic.isDynamicRoute)(route)) {\n                  _context2.next = 119;\n                  break;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                asPathname = parsedAs.pathname;\n                routeRegex = (0, _routeregex.getRouteRegex)(route);\n                routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context2.next = 118;\n                  break;\n                }\n\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param] && !routeRegex.groups[param].optional;\n                });\n\n                if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                  _context2.next = 116;\n                  break;\n                }\n\n                if (true) {\n                  console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                }\n\n                throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n\n              case 116:\n                _context2.next = 119;\n                break;\n\n              case 118:\n                if (shouldInterpolate) {\n                  as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n\n              case 119:\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeStart\", as, routeProps);\n                }\n\n                isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n                _context2.prev = 121;\n                _context2.next = 124;\n                return this.getRouteInfo({\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: routeProps,\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  hasMiddleware: isMiddlewareMatch,\n                  unstable_skipClientCache: options.unstable_skipClientCache,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback,\n                  isMiddlewareRewrite: isMiddlewareRewrite\n                });\n\n              case 124:\n                routeInfo = _context2.sent;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 128;\n                  break;\n                }\n\n                _context2.next = 128;\n                return this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n\n              case 128:\n                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                  pathname = routeInfo.route || route;\n                  route = pathname;\n\n                  if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                  }\n\n                  cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n\n                  if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach(function (key) {\n                      if (routeMatch && query[key] === routeMatch[key]) {\n                        delete query[key];\n                      }\n                    });\n                  }\n\n                  if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    rewriteAs = prefixedAs;\n\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                      rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n\n                    if (false) {}\n\n                    _routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    curRouteMatch = (0, _routematcher.getRouteMatcher)(_routeRegex)(new URL(rewriteAs, location.href).pathname);\n\n                    if (curRouteMatch) {\n                      Object.assign(query, curRouteMatch);\n                    }\n                  }\n                } // If the routeInfo brings a redirect we simply apply it.\n\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 136;\n                  break;\n                }\n\n                if (!(routeInfo.type === \"redirect-internal\")) {\n                  _context2.next = 134;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n              case 134:\n                handleHardNavigation({\n                  url: routeInfo.destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 136:\n                component = routeInfo.Component;\n\n                if (component && component.unstable_scriptLoader) {\n                  scripts = [].concat(component.unstable_scriptLoader());\n                  scripts.forEach(function (script) {\n                    (0, _script.handleClientScriptLoad)(script.props);\n                  });\n                } // handle redirect on client-transition\n\n\n                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                if (!(routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT)) {\n                  _context2.next = 149;\n                  break;\n                }\n\n                // Use the destination from redirect without adding locale\n                options.locale = false;\n                destination = routeInfo.props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n\n                if (!(destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context2.next = 147;\n                  break;\n                }\n\n                parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context2.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n\n              case 147:\n                handleHardNavigation({\n                  url: destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 149:\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW; // handle SSG data 404\n\n                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                _context2.prev = 151;\n                _context2.next = 154;\n                return this.fetchComponent(\"/404\");\n\n              case 154:\n                notFoundRoute = \"/404\";\n                _context2.next = 160;\n                break;\n\n              case 157:\n                _context2.prev = 157;\n                _context2.t3 = _context2[\"catch\"](151);\n                notFoundRoute = \"/_error\";\n\n              case 160:\n                _context2.next = 162;\n                return this.getRouteInfo({\n                  route: notFoundRoute,\n                  pathname: notFoundRoute,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isNotFound: true\n                });\n\n              case 162:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on /404\");\n\n              case 165:\n                if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                // shallow routing is only allowed for same page URL changes.\n                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null;\n                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // the new state that the router gonna set\n\n                upcomingRouterState = _objectSpread(_objectSpread({}, nextState), {}, {\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  asPath: cleanedAs,\n                  isFallback: false\n                }); // When the page being rendered is the 404 page, we should only update the\n                // query parameters. Route changes here might add the basePath when it\n                // wasn't originally present. This is also why this block is before the\n                // below `changeState` call which updates the browser's history (changing\n                // the URL).\n\n                if (!(isQueryUpdating && isErrorRoute)) {\n                  _context2.next = 188;\n                  break;\n                }\n\n                _context2.next = 174;\n                return this.getRouteInfo({\n                  route: this.pathname,\n                  pathname: this.pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n\n              case 174:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 177;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n\n              case 177:\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                _context2.prev = 178;\n                _context2.next = 181;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 181:\n                _context2.next = 187;\n                break;\n\n              case 183:\n                _context2.prev = 183;\n                _context2.t4 = _context2[\"catch\"](178);\n\n                if ((0, _iserror[\"default\"])(_context2.t4) && _context2.t4.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t4, cleanedAs, routeProps);\n                }\n\n                throw _context2.t4;\n\n              case 187:\n                return _context2.abrupt(\"return\", true);\n\n              case 188:\n                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                this.changeState(method, url, as, options); // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n\n                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n\n                if (canSkipUpdating) {\n                  _context2.next = 211;\n                  break;\n                }\n\n                _context2.prev = 192;\n                _context2.next = 195;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 195:\n                _context2.next = 204;\n                break;\n\n              case 197:\n                _context2.prev = 197;\n                _context2.t5 = _context2[\"catch\"](192);\n\n                if (!_context2.t5.cancelled) {\n                  _context2.next = 203;\n                  break;\n                }\n\n                routeInfo.error = routeInfo.error || _context2.t5;\n                _context2.next = 204;\n                break;\n\n              case 203:\n                throw _context2.t5;\n\n              case 204:\n                if (!routeInfo.error) {\n                  _context2.next = 207;\n                  break;\n                }\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                }\n\n                throw routeInfo.error;\n\n              case 207:\n                if (false) {}\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                } // A hash mark # is the optional last part of a URL\n\n\n                hashRegex = /#.+$/;\n\n                if (shouldScroll && hashRegex.test(as)) {\n                  this.scrollToHash(as);\n                }\n\n              case 211:\n                return _context2.abrupt(\"return\", true);\n\n              case 214:\n                _context2.prev = 214;\n                _context2.t6 = _context2[\"catch\"](121);\n\n                if (!((0, _iserror[\"default\"])(_context2.t6) && _context2.t6.cancelled)) {\n                  _context2.next = 218;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 218:\n                throw _context2.t6;\n\n              case 219:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[41, 46], [57, 66], [121, 214], [151, 157], [178, 183], [192, 197]]);\n      }));\n\n      function change(_x7, _x8, _x9, _x10, _x11) {\n        return _change.apply(this, arguments);\n      }\n\n      return change;\n    }()\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as, options) {\n      if (options === void 0) options = {};\n\n      if (true) {\n        if (typeof window.history === \"undefined\") {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === \"undefined\") {\n          console.error(\"Warning: window.history.\" + method + \" is not available\");\n          return;\n        }\n      }\n\n      if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== \"pushState\" ? this._key : _createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        \"\", as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function () {\n      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(err, pathname, query, as, routeProps, loadErrorFail) {\n        var props, _yield$this$fetchComp, Component, styleSheets, routeInfo;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                console.error(err);\n\n                if (!err.cancelled) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw err;\n\n              case 3:\n                if (!((0, _routeloader.isAssetError)(err) || loadErrorFail)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                Router.events.emit(\"routeChangeError\", err, as, routeProps); // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                }); // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n\n                throw buildCancellationError();\n\n              case 7:\n                _context3.prev = 7;\n                _context3.next = 10;\n                return this.fetchComponent(\"/_error\");\n\n              case 10:\n                _yield$this$fetchComp = _context3.sent;\n                Component = _yield$this$fetchComp.page;\n                styleSheets = _yield$this$fetchComp.styleSheets;\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n\n                if (routeInfo.props) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.prev = 15;\n                _context3.next = 18;\n                return this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 18:\n                routeInfo.props = _context3.sent;\n                _context3.next = 25;\n                break;\n\n              case 21:\n                _context3.prev = 21;\n                _context3.t0 = _context3[\"catch\"](15);\n                console.error(\"Error in error page `getInitialProps`: \", _context3.t0);\n                routeInfo.props = {};\n\n              case 25:\n                return _context3.abrupt(\"return\", routeInfo);\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t1 = _context3[\"catch\"](7);\n                return _context3.abrupt(\"return\", this.handleRouteInfoError((0, _iserror[\"default\"])(_context3.t1) ? _context3.t1 : new Error(_context3.t1 + \"\"), pathname, query, as, routeProps, true));\n\n              case 31:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[7, 28], [15, 21]]);\n      }));\n\n      function handleRouteInfoError(_x12, _x13, _x14, _x15, _x16, _x17) {\n        return _handleRouteInfoError.apply(this, arguments);\n      }\n\n      return handleRouteInfoError;\n    }()\n  }, {\n    key: \"getRouteInfo\",\n    value: function () {\n      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(param) {\n        var _this2 = this;\n\n        var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, resolvedRoute, pages, routeInfo, _require2, isValidElementType, wasBailedPrefetch, shouldFetchData, _yield$this$_getData, props, cacheKey;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                /**\n                * This `route` binding can change if there's a rewrite\n                * so we keep a reference to the original requested route\n                * so we can store the cache for it and avoid re-requesting every time\n                * for shallow routing purposes.\n                */\n\n                route = requestedRoute;\n                _context5.prev = 2;\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", existingInfo);\n\n              case 7:\n                if (hasMiddleware) {\n                  existingInfo = undefined;\n                }\n\n                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && false ? 0 : undefined;\n                isBackground = isQueryUpdating;\n                fetchNextDataParams = {\n                  dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale: locale\n                  }),\n                  hasMiddleware: true,\n                  isServerRender: this.isSsr,\n                  parseJSON: true,\n                  inflightCache: isBackground ? this.sbc : this.sdc,\n                  persistCache: !isPreview,\n                  isPrefetch: false,\n                  unstable_skipClientCache: unstable_skipClientCache,\n                  isBackground: isBackground\n                };\n\n                if (!(isQueryUpdating && !isMiddlewareRewrite)) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                _context5.t0 = null;\n                _context5.next = 18;\n                break;\n\n              case 15:\n                _context5.next = 17;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData(fetchNextDataParams);\n                  },\n                  asPath: isNotFound ? \"/404\" : resolvedAs,\n                  locale: locale,\n                  router: this\n                })[\"catch\"](function (err) {\n                  // we don't hard error during query updating\n                  // as it's un-necessary and doesn't need to be fatal\n                  // unless it is a fallback route and the props can't\n                  // be loaded\n                  if (isQueryUpdating) {\n                    return null;\n                  }\n\n                  throw err;\n                });\n\n              case 17:\n                _context5.t0 = _context5.sent;\n\n              case 18:\n                data = _context5.t0;\n\n                // when rendering error routes we don't apply middleware\n                // effects\n                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                  data.effect = undefined;\n                }\n\n                if (isQueryUpdating) {\n                  if (!data) {\n                    data = {\n                      json: self.__NEXT_DATA__.props\n                    };\n                  } else {\n                    data.json = self.__NEXT_DATA__.props;\n                  }\n                }\n\n                handleCancelled();\n\n                if (!((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\")) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", data.effect);\n\n              case 24:\n                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                _context5.next = 28;\n                return this.pageLoader.getPageList();\n\n              case 28:\n                pages = _context5.sent;\n\n                if (!(!isQueryUpdating || pages.includes(resolvedRoute))) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                route = resolvedRoute;\n                pathname = data.effect.resolvedHref;\n                query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname); // Check again the cache with the new destination.\n\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route && !hasMiddleware)) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", _objectSpread(_objectSpread({}, existingInfo), {}, {\n                  route: route\n                }));\n\n              case 37:\n                if (!(0, _isapiroute.isAPIRoute)(route)) {\n                  _context5.next = 40;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context5.abrupt(\"return\", new Promise(function () {}));\n\n              case 40:\n                _context5.t1 = cachedRouteInfo;\n\n                if (_context5.t1) {\n                  _context5.next = 45;\n                  break;\n                }\n\n                _context5.next = 44;\n                return this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                  };\n                });\n\n              case 44:\n                _context5.t1 = _context5.sent;\n\n              case 45:\n                routeInfo = _context5.t1;\n\n                if (false) {}\n\n                _require2 = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\"), isValidElementType = _require2.isValidElementType;\n\n                if (isValidElementType(routeInfo.Component)) {\n                  _context5.next = 50;\n                  break;\n                }\n\n                throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n\n              case 50:\n                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP; // For non-SSG prefetches that bailed before sending data\n                // we clear the cache to fetch full response\n\n                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                  delete this.sdc[data.dataHref];\n                }\n\n                _context5.next = 55;\n                return this._getData( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n                  var dataHref, fetched;\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          if (!shouldFetchData) {\n                            _context4.next = 8;\n                            break;\n                          }\n\n                          if (!((data == null ? void 0 : data.json) && !wasBailedPrefetch)) {\n                            _context4.next = 3;\n                            break;\n                          }\n\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                          });\n\n                        case 3:\n                          dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this2.pageLoader.getDataHref({\n                            href: (0, _formaturl.formatWithValidation)({\n                              pathname: pathname,\n                              query: query\n                            }),\n                            asPath: resolvedAs,\n                            locale: locale\n                          });\n                          _context4.next = 6;\n                          return fetchNextData({\n                            dataHref: dataHref,\n                            isServerRender: _this2.isSsr,\n                            parseJSON: true,\n                            inflightCache: wasBailedPrefetch ? {} : _this2.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache: unstable_skipClientCache\n                          });\n\n                        case 6:\n                          fetched = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: fetched.cacheKey,\n                            props: fetched.json || {}\n                          });\n\n                        case 8:\n                          _context4.t0 = {};\n                          _context4.next = 11;\n                          return _this2.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                          {\n                            pathname: pathname,\n                            query: query,\n                            asPath: as,\n                            locale: locale,\n                            locales: _this2.locales,\n                            defaultLocale: _this2.defaultLocale\n                          });\n\n                        case 11:\n                          _context4.t1 = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            headers: _context4.t0,\n                            props: _context4.t1\n                          });\n\n                        case 13:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                })));\n\n              case 55:\n                _yield$this$_getData = _context5.sent;\n                props = _yield$this$_getData.props;\n                cacheKey = _yield$this$_getData.cacheKey;\n\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                  delete this.sdc[cacheKey];\n                } // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n\n\n                if (!this.isPreview && routeInfo.__N_SSG && false && 0) {}\n\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                this.components[route] = routeInfo;\n                return _context5.abrupt(\"return\", routeInfo);\n\n              case 69:\n                _context5.prev = 69;\n                _context5.t2 = _context5[\"catch\"](2);\n                return _context5.abrupt(\"return\", this.handleRouteInfoError((0, _iserror.getProperError)(_context5.t2), pathname, query, as, routeProps));\n\n              case 72:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 69]]);\n      }));\n\n      function getRouteInfo(_x18) {\n        return _getRouteInfo.apply(this, arguments);\n      }\n\n      return getRouteInfo;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split(\"#\"),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split(\"#\"),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split(\"#\"),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? \"\" : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === \"\" || hash === \"top\") {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function () {\n      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(url, asPath, options) {\n        var _this3 = this;\n\n        var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield, rewritesResult, data, route;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (asPath === void 0) asPath = url;\n                if (options === void 0) options = {}; // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n                if (false) {}\n\n                return _context6.abrupt(\"return\");\n\n              case 4:\n                if (!( true && (0, _isbot.isBot)(window.navigator.userAgent))) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 6:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                urlPathname = parsed.pathname;\n                pathname = parsed.pathname, query = parsed.query;\n                originalPathname = pathname;\n\n                if (false) {}\n\n                _context6.next = 13;\n                return this.pageLoader.getPageList();\n\n              case 13:\n                pages = _context6.sent;\n                resolvedAs = asPath;\n                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n                _context6.next = 18;\n                return _matchesMiddleware({\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 18:\n                isMiddlewareMatch = _context6.sent;\n\n                if (true) {\n                  _context6.next = 29;\n                  break;\n                }\n\n                _context6.next = 22;\n                return (0, _routeloader.getClientBuildManifest)();\n\n              case 22:\n                _yield = _context6.sent;\n                rewrites = _yield.__rewrites;\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context6.next = 27;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 27:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 29:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                if (true) {\n                  _context6.next = 35;\n                  break;\n                }\n\n                _context6.t0 = null;\n                _context6.next = 38;\n                break;\n\n              case 35:\n                _context6.next = 37;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData({\n                      dataHref: _this3.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                          pathname: originalPathname,\n                          query: query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale: locale\n                      }),\n                      hasMiddleware: true,\n                      isServerRender: _this3.isSsr,\n                      parseJSON: true,\n                      inflightCache: _this3.sdc,\n                      persistCache: !_this3.isPreview,\n                      isPrefetch: true\n                    });\n                  },\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 37:\n                _context6.t0 = _context6.sent;\n\n              case 38:\n                data = _context6.t0;\n\n                /**\n                * If there was a rewrite we apply the effects of the rewrite on the\n                * current parameters for the prefetch.\n                */\n                if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                  parsed.pathname = data.effect.resolvedHref;\n                  pathname = data.effect.resolvedHref;\n                  query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                  resolvedAs = data.effect.parsedAs.pathname;\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n                /**\n                * If there is a redirect to an external destination then we don't have\n                * to prefetch content as it will be unused.\n                */\n\n\n                if (!((data == null ? void 0 : data.effect.type) === \"redirect-external\")) {\n                  _context6.next = 42;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 42:\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                _context6.next = 45;\n                return this._bfl(asPath, resolvedAs, options.locale, true);\n\n              case 45:\n                if (!_context6.sent) {\n                  _context6.next = 47;\n                  break;\n                }\n\n                this.components[urlPathname] = {\n                  __appRouter: true\n                };\n\n              case 47:\n                _context6.next = 49;\n                return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this3.pageLoader.getDataHref({\n                      href: url,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: _this3.sdc,\n                    persistCache: !_this3.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                  }).then(function () {\n                    return false;\n                  })[\"catch\"](function () {\n                    return false;\n                  }) : false;\n                }), this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n\n              case 49:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function prefetch(_x19, _x20, _x21) {\n        return _prefetch.apply(this, arguments);\n      }\n\n      return prefetch;\n    }()\n  }, {\n    key: \"fetchComponent\",\n    value: function () {\n      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(route) {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                _context7.prev = 1;\n                _context7.next = 4;\n                return this.pageLoader.loadPage(route);\n\n              case 4:\n                componentResult = _context7.sent;\n                handleCancelled();\n                return _context7.abrupt(\"return\", componentResult);\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](1);\n                handleCancelled();\n                throw _context7.t0;\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[1, 9]]);\n      }));\n\n      function fetchComponent(_x22) {\n        return _fetchComponent.apply(this, arguments);\n      }\n\n      return fetchComponent;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this4 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this4.clc) {\n          _this4.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error(\"Loading initial props cancelled\");\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (param) {\n        var text = param.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components[\"/_app\"].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils.loadGetInitialProps)(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n\n  return Router;\n}();\n\n(function () {\n  Router.events = (0, _mitt[\"default\"])();\n})();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQSxNQUFNQyxDQUFOOztBQUtBLFNBQVNHLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxHQUF6QixFQUE4QjtFQUMxQixLQUFJLElBQUlDLElBQVIsSUFBZ0JELEdBQWhCO0lBQW9CVCxNQUFNLENBQUNDLGNBQVAsQ0FBc0JPLE1BQXRCLEVBQThCRSxJQUE5QixFQUFvQztNQUNwREMsVUFBVSxFQUFFLElBRHdDO01BRXBEQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBRDtJQUY0QyxDQUFwQztFQUFwQjtBQUlIOztBQUNESCxPQUFPLENBQUNMLE9BQUQsRUFBVTtFQUNiLFdBQVMsb0JBQVc7SUFDaEIsT0FBT1csTUFBUDtFQUNILENBSFk7RUFJYlIsaUJBQWlCLEVBQUUsNkJBQVc7SUFDMUIsT0FBT0Esa0JBQVA7RUFDSCxDQU5ZO0VBT2JDLFNBQVMsRUFBRSxxQkFBVztJQUNsQixPQUFPQSxVQUFQO0VBQ0g7QUFUWSxDQUFWLENBQVA7O0FBV0EsSUFBTVEsd0JBQXdCLEdBQUdDLG1CQUFPLENBQUMsNEdBQUQsQ0FBeEM7O0FBQ0EsSUFBTUMseUJBQXlCLEdBQUdELG1CQUFPLENBQUMsOEdBQUQsQ0FBekM7O0FBQ0EsSUFBTUUsb0JBQW9CLEdBQUdGLG1CQUFPLENBQUMsZ0hBQUQsQ0FBcEM7O0FBQ0EsSUFBTUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHFGQUFELENBQTVCOztBQUNBLElBQU1JLE9BQU8sR0FBR0osbUJBQU8sQ0FBQyx5RUFBRCxDQUF2Qjs7QUFDQSxJQUFNSyxRQUFRLEdBQUcsYUFBY0oseUJBQXlCLENBQUNLLENBQTFCLENBQTRCTixtQkFBTyxDQUFDLHVFQUFELENBQW5DLENBQS9COztBQUNB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S0FBSyxXQUFULEdBQWhCO0FBQ0gsQ0FGRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogbnVsbCxcbiAgICBjcmVhdGVLZXk6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzTWlkZGxld2FyZTtcbiAgICB9LFxuICAgIGNyZWF0ZUtleTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVLZXk7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfcm91dGVsb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbmNvbnN0IF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG5jb25zdCBfZGVub3JtYWxpemVwYWdlcGF0aCA9IHJlcXVpcmUoXCIuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xuY29uc3QgX25vcm1hbGl6ZWxvY2FsZXBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbmNvbnN0IF9yZXNvbHZlcmV3cml0ZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmVsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfaXNhcGlyb3V0ZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlXCIpO1xuY29uc3QgX2dldG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2NvbXBhcmVzdGF0ZXMgPSByZXF1aXJlKFwiLi91dGlscy9jb21wYXJlLXN0YXRlc1wiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2lzYm90ID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtYm90XCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi91dGlscy9vbWl0XCIpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi91dGlscy9pbnRlcnBvbGF0ZS1hc1wiKTtcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKFwiUm91dGUgQ2FuY2VsbGVkXCIpLCB7XG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucykge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpKTtcbiAgICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkob3B0aW9ucy5hc1BhdGgpO1xuICAgIC8vIHJlbW92ZSBiYXNlUGF0aCBmaXJzdCBzaW5jZSBwYXRoIHByZWZpeCBoYXMgdG8gYmUgaW4gdGhlIG9yZGVyIG9mIGAvJHtiYXNlUGF0aH0vJHtsb2NhbGV9YFxuICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzUGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXNQYXRobmFtZSkgOiBhc1BhdGhuYW1lO1xuICAgIGNvbnN0IGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShjbGVhbmVkQXMsIG9wdGlvbnMubG9jYWxlKSk7XG4gICAgLy8gQ2hlY2sgb25seSBwYXRoIG1hdGNoIG9uIGNsaWVudC4gTWF0Y2hpbmcgXCJoYXNcIiBzaG91bGQgYmUgZG9uZSBvbiBzZXJ2ZXJcbiAgICAvLyB3aGVyZSB3ZSBjYW4gYWNjZXNzIG1vcmUgaW5mbyBzdWNoIGFzIGhlYWRlcnMsIEh0dHBPbmx5IGNvb2tpZSwgZXRjLlxuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtKT0+bmV3IFJlZ0V4cChtLnJlZ2V4cCkudGVzdChhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSkpO1xufVxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmw7XG59XG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyLCB1cmwsIGFzKSB7XG4gICAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIHVybCwgdHJ1ZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICBjb25zdCBocmVmV2FzQWJzb2x1dGUgPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIGNvbnN0IGFzV2FzQWJzb2x1dGUgPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmV2FzQWJzb2x1dGUgPyByZXNvbHZlZEhyZWYgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShyZXNvbHZlZEhyZWYpO1xuICAgIGNvbnN0IHByZXBhcmVkQXMgPSBhcyA/IHN0cmlwT3JpZ2luKCgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgYXMpKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgICAgIGFzOiBhc1dhc0Fic29sdXRlID8gcHJlcGFyZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHByZXBhcmVkQXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKSB7XG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX2Rlbm9ybWFsaXplcGFnZXBhdGguZGVub3JtYWxpemVQYWdlUGF0aCkocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgY2xlYW5QYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpPT57XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhZ2UpICYmICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG59XG5mdW5jdGlvbiBnZXRNaWRkbGV3YXJlRGF0YShzb3VyY2UsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dENvbmZpZyA9IHtcbiAgICAgICAgYmFzZVBhdGg6IG9wdGlvbnMucm91dGVyLmJhc2VQYXRoLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBsb2NhbGVzOiBvcHRpb25zLnJvdXRlci5sb2NhbGVzXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWlsaW5nU2xhc2g6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKVxuICAgIH07XG4gICAgY29uc3QgcmV3cml0ZUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtcmV3cml0ZVwiKTtcbiAgICBsZXQgcmV3cml0ZVRhcmdldCA9IHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1tYXRjaGVkLXBhdGhcIik7XG4gICAgY29uc3QgbWF0Y2hlZFBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWF0Y2hlZC1wYXRoXCIpO1xuICAgIGlmIChtYXRjaGVkUGF0aCAmJiAhcmV3cml0ZVRhcmdldCAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCJfX25leHRfZGF0YV9jYXRjaGFsbFwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvX2Vycm9yXCIpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIi80MDRcIikpIHtcbiAgICAgICAgLy8gbGV2ZXJhZ2UgeC1tYXRjaGVkLXBhdGggdG8gZGV0ZWN0IG5leHQuY29uZmlnLmpzIHJld3JpdGVzXG4gICAgICAgIHJld3JpdGVUYXJnZXQgPSBtYXRjaGVkUGF0aDtcbiAgICB9XG4gICAgaWYgKHJld3JpdGVUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJld3JpdGVUYXJnZXQuc3RhcnRzV2l0aChcIi9cIikgfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZXdyaXRlVGFyZ2V0ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJld3JpdGVUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWVJbmZvID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZnNQYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZUluZm8ucGF0aG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpXG4gICAgICAgICAgICBdKS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKGFzKSB8fCAhcmV3cml0ZUhlYWRlciAmJiBwYWdlcy5pbmNsdWRlcygoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnOiBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTID8gdW5kZWZpbmVkIDogbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRTb3VyY2UucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKGFzLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIChwYXRoKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gcmVzdWx0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpID8gcmVzb2x2ZUR5bmFtaWNSb3V0ZSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lLCBwYWdlcykgOiBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocmVzb2x2ZWRIcmVmKSkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIG1hdGNoZXMgfHwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJld3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0VGFyZ2V0ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZWRpcmVjdFwiKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWludGVybmFsXCIsXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxuICAgICAgICAgICAgICAgIG5ld1VybDogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdHlwZTogXCJuZXh0XCJcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBvcHRpb25zLmZldGNoRGF0YSgpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSBhd2FpdCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgICAgICAgICAganNvbjogZGF0YS5qc29uLFxuICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLnRleHQsXG4gICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyoqXG4gICAgICogVE9ETzogUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXG4gICAgICogRm9yIG5vdyB3ZSB3aWxsIG5vdCBjb25zaWRlciBtaWRkbGV3YXJlIGRhdGEgZXJyb3JzIHRvIGJlIGZhdGFsLlxuICAgICAqIG1heWJlIHdlIHNob3VsZCByZXZpc2l0IGluIHRoZSBmdXR1cmUuXG4gICAgICovIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwic2Nyb2xsUmVzdG9yYXRpb25cIiBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gXCJfX25leHRcIjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcbiAgICB9IGNhdGNoIChuKSB7fVxufSgpO1xuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKFwiU1NHX0RBVEFfTk9UX0ZPVU5EXCIpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgXCJ4LW5leHRqcy1kYXRhXCI6IFwiMVwiXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXJhbSkge1xuICAgIGxldCB7IGRhdGFIcmVmICwgaW5mbGlnaHRDYWNoZSAsIGlzUHJlZmV0Y2ggLCBoYXNNaWRkbGV3YXJlICwgaXNTZXJ2ZXJSZW5kZXIgLCBwYXJzZUpTT04gLCBwZXJzaXN0Q2FjaGUgLCBpc0JhY2tncm91bmQgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgIH0gPSBwYXJhbTtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHZhciBfcGFyYW1zX21ldGhvZDtcbiAgICBjb25zdCBnZXREYXRhID0gKHBhcmFtcyk9PntcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGlzUHJlZmV0Y2ggPyB7XG4gICAgICAgICAgICAgICAgcHVycG9zZTogXCJwcmVmZXRjaFwiXG4gICAgICAgICAgICB9IDoge30sIGlzUHJlZmV0Y2ggJiYgaGFzTWlkZGxld2FyZSA/IHtcbiAgICAgICAgICAgICAgICBcIngtbWlkZGxld2FyZS1wcmVmZXRjaFwiOiBcIjFcIlxuICAgICAgICAgICAgfSA6IHt9KSxcbiAgICAgICAgICAgIG1ldGhvZDogKF9wYXJhbXNfbWV0aG9kID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSAhPSBudWxsID8gX3BhcmFtc19tZXRob2QgOiBcIkdFVFwiXG4gICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovIGlmIChoYXNNaWRkbGV3YXJlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwOFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdHJ5VG9QYXJzZUFzSlNPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX3RyeVRvUGFyc2VBc0pTT04gPSB0cnlUb1BhcnNlQXNKU09OKHRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RyeVRvUGFyc2VBc0pTT04ubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzXCIpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXG4gICAgICAgICAgICAgKiBjYXVzZWQgb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG9cbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAgKi8gaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5tYXJrQXNzZXRFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAganNvbjogcGFyc2VKU09OID8gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLWNhY2hlXCIpID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGlmICghdW5zdGFibGVfc2tpcENsaWVudENhY2hlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8vIGNocm9tZVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgLy8gZmlyZWZveFxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIiB8fCAvLyBzYWZhcmlcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gICAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAgIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIlxuICAgIH0gOiB7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsICwgcm91dGVyICB9ID0gcGFyYW07XG4gICAgLy8gZW5zdXJlIHdlIGRvbid0IHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIHNhbWVcbiAgICAvLyBVUkwgYXMgdGhpcyBjYW4gZW5kIHVwIHdpdGggYW4gaW5maW5pdGUgcmVmcmVzaFxuICAgIGlmICh1cmwgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocm91dGVyLmFzUGF0aCwgcm91dGVyLmxvY2FsZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMIFwiICsgdXJsICsgXCIgXCIgKyBsb2NhdGlvbi5ocmVmKTtcbiAgICB9XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG59XG5jb25zdCBnZXRDYW5jZWxsZWRIYW5kbGVyID0gKHBhcmFtKT0+e1xuICAgIGxldCB7IHJvdXRlICwgcm91dGVyICB9ID0gcGFyYW07XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbmNlbCA9IHJvdXRlci5jbGMgPSAoKT0+e1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCk9PntcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0Fib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJyArIHJvdXRlICsgJ1wiJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgICAgICAgcm91dGVyLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVDYW5jZWxsZWQ7XG59O1xuY2xhc3MgUm91dGVyIHtcbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqLyBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJwdXNoU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJyZXBsYWNlU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9iZmwoYXMsIHJlc29sdmVkQXMsIGxvY2FsZSwgc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjdXJBcyBvZiBbXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1xuICAgICAgICAgICAgXSl7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKGN1ckFzLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoTG9jYWxlID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc05vU2xhc2gsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNOb1NsYXNoICE9PSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkobmV3IFVSTCh0aGlzLmFzUGF0aCwgXCJodHRwOi8vblwiKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fYmZsX3MsIF90aGlzX19iZmxfczE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsU3RhdGljID0gbWF0Y2hlc0JmbFN0YXRpYyB8fCAhISgoX3RoaXNfX2JmbF9zID0gdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MuaGFzKGFzTm9TbGFzaCkpIHx8ICEhKChfdGhpc19fYmZsX3MxID0gdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MxLmhhcyhhc05vU2xhc2hMb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyAhbWF0Y2hlc0JmbER5bmFtaWMgJiYgaSA8IGN1ckFzUGFydHMubGVuZ3RoICsgMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChfdGhpc19fYmZsX2QgPSB0aGlzLl9iZmxfZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfZC5oYXMoY3VycmVudFBhcnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc0JmbER5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0JmbFN0YXRpYyB8fCBtYXRjaGVzQmZsRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGNoYW5nZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMsIGZvcmNlZFNjcm9sbCkge1xuICAgICAgICB2YXIgX3RoaXNfY29tcG9uZW50c19wYXRobmFtZTtcbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkodXJsKSkge1xuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgY29uc3QgaXNRdWVyeVVwZGF0aW5nID0gb3B0aW9ucy5faCA9PT0gMTtcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCB1bmRlZmluZWQsIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2hvdWxkUmVzb2x2ZUhyZWYgPSBpc1F1ZXJ5VXBkYXRpbmcgfHwgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgfHwgKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKSh1cmwpLnBhdGhuYW1lID09PSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKGFzKS5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZVxuICAgICAgICB9O1xuICAgICAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcbiAgICAgICAgY29uc3QgcmVhZHlTdGF0ZUNoYW5nZSA9IHRoaXMuaXNSZWFkeSAhPT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXNTc3IgPSB0aGlzLmlzU3NyO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGEgcm91dGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGJlZm9yZVxuICAgICAgICAvLyB0aGUgcXVlcnkgdXBkYXRpbmcgaXMgdHJpZ2dlcmVkIGlnbm9yZSBxdWVyeSB1cGRhdGluZ1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMuY2xjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID8gdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHVybCkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKSh1cmwpIDogdXJsLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzX2xvY2FsZXM7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICAgICAgICAgIGlmICghKChfdGhpc19sb2NhbGVzID0gdGhpcy5sb2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfbG9jYWxlcy5pbmNsdWRlcyhuZXh0U3RhdGUubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHBhcnNlZEFzLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSAoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKHRoaXMuZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgICAgICAgICBpZiAoIWRpZE5hdmlnYXRlICYmIGRldGVjdGVkRG9tYWluICYmIHRoaXMuaXNMb2NhbGVEb21haW4gJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImh0dHBcIiArIChkZXRlY3RlZERvbWFpbi5odHRwID8gXCJcIiA6IFwic1wiKSArIFwiOi8vXCIgKyBkZXRlY3RlZERvbWFpbi5kb21haW4gKyAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShcIlwiICsgKG5leHRTdGF0ZS5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyBcIlwiIDogXCIvXCIgKyBuZXh0U3RhdGUubG9jYWxlKSArIChhc05vQmFzZVBhdGggPT09IFwiL1wiID8gXCJcIiA6IGFzTm9CYXNlUGF0aCkgfHwgXCIvXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKFwicm91dGVDaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ID1mYWxzZSAsIHNjcm9sbCA9dHJ1ZSAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7XG4gICAgICAgICAgICBzaGFsbG93XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlICYmIHRoaXMuY2xjKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3NyKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGMoKTtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgY29uc3QgbG9jYWxlQ2hhbmdlID0gcHJldkxvY2FsZSAhPT0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5hc1BhdGggPSBjbGVhbmVkQXM7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJoYXNoQ2hhbmdlU3RhcnRcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzY3JvbGw6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldChuZXh0U3RhdGUsIHRoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJoYXNoQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBpZiB3ZSBkZXRlY3RlZCB0aGUgcGF0aCBhcyBhcHAgcm91dGUgZHVyaW5nIHByZWZldGNoaW5nXG4gICAgICAgIC8vIHRyaWdnZXIgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICgoX3RoaXNfY29tcG9uZW50c19wYXRobmFtZSA9IHRoaXMuY29tcG9uZW50c1twYXRobmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lLl9fYXBwUm91dGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgICAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAgICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICAgICAgbGV0IHBhZ2VzLCByZXdyaXRlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpLFxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwicmVwbGFjZVN0YXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgIGxldCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFzUGF0aG5hbWUgPSBhcy5zdGFydHNXaXRoKFwiL1wiKSAmJiAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVSZXdyaXRlID0gISEocGFyc2VkQXNQYXRobmFtZSAmJiByb3V0ZSAhPT0gcGFyc2VkQXNQYXRobmFtZSAmJiAoISgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkgfHwgISgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKSkocGFyc2VkQXNQYXRobmFtZSkpKTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgYXR0ZW1wdCByZXNvbHZlIGFzUGF0aCB3aGVuIHdlIG5lZWQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9ICFvcHRpb25zLnNoYWxsb3cgJiYgYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgc2hvdWxkUmVzb2x2ZUhyZWYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShjbGVhbmVkQXMsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBxdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGFzKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBocmVmOiBcIicgKyB1cmwgKyAnXCIgYW5kIGFzOiBcIicgKyBhcyArICdcIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXMnICsgXCJcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGxldCByb3V0ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpO1xuICAgICAgICAgICAgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/ICgwLCBfaW50ZXJwb2xhdGVhcy5pbnRlcnBvbGF0ZUFzKShyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge307XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV0gJiYgIXJvdXRlUmVnZXguZ3JvdXBzW3BhcmFtXS5vcHRpb25hbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCAmJiAhaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcIkludGVycG9sYXRpbmcgaHJlZlwiIDogXCJNaXNtYXRjaGluZyBgYXNgIGFuZCBgaHJlZmBcIikgKyBcIiBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBcIiArIChcInRoZSBwYXJhbXM6IFwiICsgbWlzc2luZ1BhcmFtcy5qb2luKFwiLCBcIikgKyBcIiBpbiB0aGUgYGhyZWZgJ3MgYHF1ZXJ5YFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiVGhlIHByb3ZpZGVkIGBocmVmYCAoXCIgKyB1cmwgKyBcIikgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKFwiICsgbWlzc2luZ1BhcmFtcy5qb2luKFwiLCBcIikgKyBcIikgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBcIiA6IFwiVGhlIHByb3ZpZGVkIGBhc2AgdmFsdWUgKFwiICsgYXNQYXRobmFtZSArIFwiKSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgYGhyZWZgIHZhbHVlIChcIiArIHJvdXRlICsgXCIpLiBcIikgKyAoXCJSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL1wiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJocmVmLWludGVycG9sYXRpb24tZmFpbGVkXCIgOiBcImluY29tcGF0aWJsZS1ocmVmLWFzXCIpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoMCwgX29taXQub21pdCkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlU3RhcnRcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRXJyb3JSb3V0ZSA9IHRoaXMucGF0aG5hbWUgPT09IFwiLzQwNFwiIHx8IHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLCBfcm91dGVJbmZvX3Byb3BzO1xuICAgICAgICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiBpc01pZGRsZXdhcmVNYXRjaCxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgaXNNaWRkbGV3YXJlUmV3cml0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCBcInJlc29sdmVkQXNcIiBpbiByb3V0ZUluZm8gPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6IHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJyb3V0ZVwiIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcm91dGVJbmZvLnJvdXRlIHx8IHJvdXRlO1xuICAgICAgICAgICAgICAgIHJvdXRlID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZUluZm8ucXVlcnkgfHwge30sIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZC5wYXRobmFtZSkgOiBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcGF0aG5hbWUgIT09IGNsZWFuZWRQYXJzZWRQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyb3V0ZU1hdGNoKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVlcnlba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPSAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXdyaXRlQXMgPSBwcmVmaXhlZEFzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkocmV3cml0ZUFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZUFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHJld3JpdGVBcywgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9IGxvY2FsZVJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyUm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkobmV3IFVSTChyZXdyaXRlQXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGN1clJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHJvdXRlSW5mbyBicmluZ3MgYSByZWRpcmVjdCB3ZSBzaW1wbHkgYXBwbHkgaXQuXG4gICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby50eXBlID09PSBcInJlZGlyZWN0LWludGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgcm91dGVJbmZvLm5ld1VybCwgcm91dGVJbmZvLm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJvdXRlSW5mby5kZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcm91dGVJbmZvLkNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdHMgPSBbXS5jb25jYXQoY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcigpKTtcbiAgICAgICAgICAgICAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCk9PntcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9zY3JpcHQuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCkoc2NyaXB0LnByb3BzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgICAgICAgaWYgKChyb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUCkgJiYgcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZXN0aW5hdGlvbiBmcm9tIHJlZGlyZWN0IHdpdGhvdXQgYWRkaW5nIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKFwiL1wiKSAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiLzQwNFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvX2Vycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIiAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm91dGVJbmZvX3JvdXRlO1xuICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlSW5mb19yb3V0ZSA9IHJvdXRlSW5mby5yb3V0ZSkgIT0gbnVsbCA/IF9yb3V0ZUluZm9fcm91dGUgOiByb3V0ZSk7XG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9vcHRpb25zX3Njcm9sbCA9IG9wdGlvbnMuc2Nyb2xsKSAhPSBudWxsID8gX29wdGlvbnNfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsICE9IG51bGwgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbDtcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgY29uc3QgdXBjb21pbmdSb3V0ZXJTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIGJlaW5nIHJlbmRlcmVkIGlzIHRoZSA0MDQgcGFnZSwgd2Ugc2hvdWxkIG9ubHkgdXBkYXRlIHRoZVxuICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIGJlbG93IGBjaGFuZ2VTdGF0ZWAgY2FsbCB3aGljaCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgaGlzdG9yeSAoY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSwgX3JvdXRlSW5mb19wcm9wczE7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gXCIgKyB0aGlzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzMSA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMxLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImJlZm9yZUhpc3RvcnlDaGFuZ2VcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVzdGF0ZXMuY29tcGFyZVJvdXRlclN0YXRlcykodXBjb21pbmdSb3V0ZXJTdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgcm91dGVJbmZvLmVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgJiYgaGFzaFJlZ2V4LnRlc3QoYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS5cIiArIG1ldGhvZCArIFwiIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgfHwgKDAsIF91dGlscy5nZXRVUkwpKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcbiAgICAgICAgICAgIH0sIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICAgICBcIlwiLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVsb2FkZXIuaXNBc3NldEVycm9yKShlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvX2Vycm9yXCIpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogXCIsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgXCJcIiksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJvdXRlSW5mbyhwYXJhbSkge1xuICAgICAgICBsZXQgeyByb3V0ZTogcmVxdWVzdGVkUm91dGUgLCBwYXRobmFtZSAsIHF1ZXJ5ICwgYXMgLCByZXNvbHZlZEFzICwgcm91dGVQcm9wcyAsIGxvY2FsZSAsIGhhc01pZGRsZXdhcmUgLCBpc1ByZXZpZXcgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgLCBpc1F1ZXJ5VXBkYXRpbmcgLCBpc01pZGRsZXdhcmVSZXdyaXRlICwgaXNOb3RGb3VuZCAgfSA9IHBhcmFtO1xuICAgICAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9kYXRhX2VmZmVjdCwgX2RhdGFfZWZmZWN0MSwgX2RhdGFfZWZmZWN0MiwgX2RhdGFfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPSBleGlzdGluZ0luZm8gJiYgIShcImluaXRpYWxcIiBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgPyBleGlzdGluZ0luZm8gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc0JhY2tncm91bmQgPSBpc1F1ZXJ5VXBkYXRpbmc7XG4gICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogaXNCYWNrZ3JvdW5kID8gdGhpcy5zYmMgOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyBcIi80MDRcIiA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhcmQgZXJyb3IgZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09IFwiL19lcnJvclwiIHx8IHBhdGhuYW1lID09PSBcIi80MDRcIikpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdCA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWludGVybmFsXCIgfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QxID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QxLnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5lZmZlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QyID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QyLnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGU7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlICYmICFoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCByb3V0ZSBkdWUgdG8gcmV3cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjb3B5IHRoZSBleGlzdGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmV3cml0dGVuIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBfaXNhcGlyb3V0ZS5pc0FQSVJvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShyb3V0ZUluZm8uQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCInICsgcGF0aG5hbWUgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3YXNCYWlsZWRQcmVmZXRjaCA9IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9yZXNwb25zZSA9IGRhdGEucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9yZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWlkZGxld2FyZS1za2lwXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hEYXRhID0gcm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1A7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLVNTRyBwcmVmZXRjaGVzIHRoYXQgYmFpbGVkIGJlZm9yZSBzZW5kaW5nIGRhdGFcbiAgICAgICAgICAgIC8vIHdlIGNsZWFyIHRoZSBjYWNoZSB0byBmZXRjaCBmdWxsIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAod2FzQmFpbGVkUHJlZmV0Y2ggJiYgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2RhdGEuZGF0YUhyZWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyAsIGNhY2hlS2V5ICB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmICFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBmZXRjaE5leHREYXRhKE9iamVjdC5hc3NpZ24oe30sIGZldGNoTmV4dERhdGFQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNiY1xuICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucGFnZVByb3BzKTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgcm91dGVJbmZvLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5nZXRQcm9wZXJFcnJvcikoZXJyKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHN0YXRlLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdChcIiNcIik7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoXCIjXCIpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoID0gXCJcIl0gPSBhcy5zcGxpdChcIiNcIik7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSBcIlwiIHx8IGhhc2ggPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PndpbmRvdy5zY3JvbGxUbygwLCAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVjb2RlIGhhc2ggdG8gbWFrZSBub24tbGF0aW4gYW5jaG9yIHdvcmtzLlxuICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpO1xuICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmF3SGFzaCk7XG4gICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT5pZEVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUocmF3SGFzaClbMF07XG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9Pm5hbWVFbC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhc1BhdGggPT09IHZvaWQgMCkgYXNQYXRoID0gdXJsO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICgwLCBfaXNib3QuaXNCb3QpKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXG4gICAgICAgICAgICAvLyBwcmVmZXRjaGVzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgY29uc3QgdXJsUGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG9jYWxlIHx8IHVuZGVmaW5lZCA6IHRoaXMubG9jYWxlO1xuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgbGV0IHJld3JpdGVzO1xuICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSBhd2FpdCAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCkpO1xuICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzUGF0aCwgdGhpcy5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhcnNlZC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXJzZWQucGF0aG5hbWUpKSgoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKGFzUGF0aCkucGF0aG5hbWUpIHx8IHt9KTtcbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09IFwic3RyaWN0XCIgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG9yaWdpbmFsUGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgd2FzIGEgcmV3cml0ZSB3ZSBhcHBseSB0aGUgZWZmZWN0cyBvZiB0aGUgcmV3cml0ZSBvbiB0aGVcbiAgICAgKiBjdXJyZW50IHBhcmFtZXRlcnMgZm9yIHRoZSBwcmVmZXRjaC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZXdyaXRlXCIpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IHRvIGFuIGV4dGVybmFsIGRlc3RpbmF0aW9uIHRoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIHRvIHByZWZldGNoIGNvbnRlbnQgYXMgaXQgd2lsbCBiZSB1bnVzZWQuXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuX2JmbChhc1BhdGgsIHJlc29sdmVkQXMsIG9wdGlvbnMubG9jYWxlLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3VybFBhdGhuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBfX2FwcFJvdXRlcjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTc2cgPyBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pID8gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fCBvcHRpb25zLnByaW9yaXR5ICYmICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFXG4gICAgICAgICAgICAgICAgfSkudGhlbigoKT0+ZmFsc2UpLmNhdGNoKCgpPT5mYWxzZSkgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyBcImxvYWRQYWdlXCIgOiBcInByZWZldGNoXCJdKHJvdXRlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEZsaWdodERhdGEoZGF0YUhyZWYpIHtcbiAgICAgICAgLy8gRG8gbm90IGNhY2hlIFJTQyBmbGlnaHQgcmVzcG9uc2Ugc2luY2UgaXQncyBub3QgYSBzdGF0aWMgcmVzb3VyY2VcbiAgICAgICAgcmV0dXJuIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHBhcnNlSlNPTjogZmFsc2UsXG4gICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZVxuICAgICAgICB9KS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IHRleHQgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwICB9ID0gdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl07XG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCk7XG4gICAgICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZTtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubG9hZEdldEluaXRpYWxQcm9wcykoQXBwLCB7XG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcm91dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lO1xuICAgIH1cbiAgICBnZXQgcXVlcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5O1xuICAgIH1cbiAgICBnZXQgYXNQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5hc1BhdGg7XG4gICAgfVxuICAgIGdldCBsb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IGlzRmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRmFsbGJhY2s7XG4gICAgfVxuICAgIGdldCBpc1ByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUHJldmlldztcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUsIHF1ZXJ5LCBhcywgeyBpbml0aWFsUHJvcHMgLCBwYWdlTG9hZGVyICwgQXBwICwgd3JhcEFwcCAsIENvbXBvbmVudCAsIGVyciAsIHN1YnNjcmlwdGlvbiAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZGVmYXVsdExvY2FsZSAsIGRvbWFpbkxvY2FsZXMgLCBpc1ByZXZpZXcgIH0pe1xuICAgICAgICAvLyBTZXJ2ZXIgRGF0YSBDYWNoZSAoZnVsbCBkYXRhIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNkYyA9IHt9O1xuICAgICAgICAvLyBTZXJ2ZXIgQmFja2dyb3VuZCBDYWNoZSAoSEVBRCByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zYmMgPSB7fTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2tleSA9IGNyZWF0ZUtleSgpO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgICAgICAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscy5nZXRVUkwpKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIHBvcHN0YXRlZXZlbnQgd2hlbiByZW9wZW5pbmcgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCAsIGFzICwgb3B0aW9ucyAsIGtleSAgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgICAgICAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLmFzUGF0aCkgJiYgcGF0aG5hbWUgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB2YWx1ZSBub3QgZXhwb3NlZCBvbiB0eXBlc1xuICAgICAgICAgICAgICAgIF9oOiAwXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICAgICAgaWYgKHBhdGhuYW1lICE9PSBcIi9fZXJyb3JcIikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBBcHAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBjb25zdCB7IEJsb29tRmlsdGVyICB9ID0gcmVxdWlyZShcIi4uLy4uL2xpYi9ibG9vbS1maWx0ZXJcIik7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVI7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSO1xuICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEuaGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MgPSBuZXcgQmxvb21GaWx0ZXIoc3RhdGljRmlsdGVyRGF0YS5zaXplLCBzdGF0aWNGaWx0ZXJEYXRhLmhhc2hlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5zaXplLCBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kLmltcG9ydChkeW5hbWljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgICAgIHRoaXMuaXNTc3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9ICEhKHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHwgc2VsZi5fX05FWFRfREFUQV9fLmFwcEdpcCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmdzcCB8fCAhYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhISgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiAhIWlzUHJldmlldyxcbiAgICAgICAgICAgIGxvY2FsZTogcHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCA/IGxvY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmICghYXMuc3RhcnRzV2l0aChcIi8vXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGhcbiAgICAgICAgICAgICAgICB9KS50aGVuKChtYXRjaGVzKT0+e1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCBtYXRjaGVzID8gYXNQYXRoIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSwgYXNQYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuKCgpPT57XG4gICAgUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dC5kZWZhdWx0KSgpO1xufSkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiY3JlYXRlS2V5IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIl9yb3V0ZWxvYWRlciIsIl9zY3JpcHQiLCJfaXNlcnJvciIsIl8iLCJfZGVub3JtYWxpemVwYWdlcGF0aCIsIl9ub3JtYWxpemVsb2NhbGVwYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNkeW5hbWljIiwiX3BhcnNlcmVsYXRpdmV1cmwiLCJfcmVzb2x2ZXJld3JpdGVzIiwiX3JvdXRlbWF0Y2hlciIsIl9yb3V0ZXJlZ2V4IiwiX2Zvcm1hdHVybCIsIl9kZXRlY3Rkb21haW5sb2NhbGUiLCJfcGFyc2VwYXRoIiwiX2FkZGxvY2FsZSIsIl9yZW1vdmVsb2NhbGUiLCJfcmVtb3ZlYmFzZXBhdGgiLCJfYWRkYmFzZXBhdGgiLCJfaGFzYmFzZXBhdGgiLCJfaXNhcGlyb3V0ZSIsIl9nZXRuZXh0cGF0aG5hbWVpbmZvIiwiX2Zvcm1hdG5leHRwYXRobmFtZWluZm8iLCJfY29tcGFyZXN0YXRlcyIsIl9pc2xvY2FsdXJsIiwiX2lzYm90IiwiX29taXQiLCJfcmVzb2x2ZWhyZWYiLCJfaW50ZXJwb2xhdGVhcyIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyb3V0ZXIiLCJwYWdlTG9hZGVyIiwiZ2V0TWlkZGxld2FyZSIsIm1hdGNoZXJzIiwicGFyc2VQYXRoIiwiYXNQYXRoIiwiYXNQYXRobmFtZSIsInBhdGhuYW1lIiwiY2xlYW5lZEFzIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJsb2NhbGUiLCJzb21lIiwibSIsIlJlZ0V4cCIsInJlZ2V4cCIsInRlc3QiLCJzdHJpcE9yaWdpbiIsInVybCIsIm9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsImxlbmd0aCIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZUhyZWYiLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwiaHJlZldhc0Fic29sdXRlIiwiYXNXYXNBYnNvbHV0ZSIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZGVub3JtYWxpemVQYWdlUGF0aCIsImluY2x1ZGVzIiwicGFnZSIsImlzRHluYW1pY1JvdXRlIiwiZ2V0Um91dGVSZWdleCIsInJlIiwiZ2V0TWlkZGxld2FyZURhdGEiLCJzb3VyY2UiLCJyZXNwb25zZSIsIm5leHRDb25maWciLCJiYXNlUGF0aCIsImkxOG4iLCJsb2NhbGVzIiwidHJhaWxpbmdTbGFzaCIsIkJvb2xlYW4iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1RSQUlMSU5HX1NMQVNIIiwicmV3cml0ZUhlYWRlciIsImhlYWRlcnMiLCJyZXdyaXRlVGFyZ2V0IiwibWF0Y2hlZFBhdGgiLCJfX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUiLCJwYXJzZWRSZXdyaXRlVGFyZ2V0IiwicGFyc2VSZWxhdGl2ZVVybCIsInBhdGhuYW1lSW5mbyIsImdldE5leHRQYXRobmFtZUluZm8iLCJwYXJzZURhdGEiLCJmc1BhdGhuYW1lIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwidGhlbiIsInBhcmFtIiwicmV3cml0ZXMiLCJfX3Jld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsImZldGNoRGF0YSIsImRhdGEiLCJkYXRhSHJlZiIsImVmZmVjdCIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwiX3BhcmFtc19tZXRob2QiLCJnZXREYXRhIiwicGFyYW1zIiwicHVycG9zZSIsIl90cnlUb1BhcnNlQXNKU09OIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsImVyciIsIm1lc3NhZ2UiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImhhbmRsZUhhcmROYXZpZ2F0aW9uIiwiZ2V0Q2FuY2VsbGVkSGFuZGxlciIsInJvdXRlIiwiY2FuY2VsIiwiY2xjIiwiaGFuZGxlQ2FuY2VsbGVkIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsInN1YnNjcmlwdGlvbiIsImlzRmFsbGJhY2siLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3Iiwic2RjIiwic2JjIiwiaXNGaXJzdFBvcFN0YXRlRXZlbnQiLCJfa2V5Iiwib25Qb3BTdGF0ZSIsImUiLCJzdGF0ZSIsImNoYW5nZVN0YXRlIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJnZXRVUkwiLCJfX05BIiwicmVsb2FkIiwiX19OIiwiZm9yY2VkU2Nyb2xsIiwia2V5Iiwic3RyaW5naWZ5IiwieCIsInNlbGYiLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEl0ZW0iLCJpc1NzciIsIl9icHMiLCJjaGFuZ2UiLCJzaGFsbG93IiwiX3NoYWxsb3ciLCJfaCIsImNvbXBvbmVudHMiLCJpbml0aWFsIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsInN0eWxlU2hlZXRzIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQiLCJCbG9vbUZpbHRlciIsInN0YXRpY0ZpbHRlckRhdGEiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiIsImR5bmFtaWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVIiLCJoYXNoZXMiLCJfYmZsX3MiLCJzaXplIiwiX2JmbF9kIiwiZXZlbnRzIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJfX05FWFRfREFUQV9fIiwiYXV0b0V4cG9ydCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJzdWIiLCJfd3JhcEFwcCIsImlzTG9jYWxlRG9tYWluIiwiaXNSZWFkeSIsImdzc3AiLCJnaXAiLCJhcHBHaXAiLCJnc3AiLCJzZWFyY2giLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiaG9zdG5hbWUiLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsIl9zaG91bGRSZXNvbHZlSHJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxSZXN0b3JhdGlvbiIsImJhY2siLCJmb3J3YXJkIiwic2tpcE5hdmlnYXRlIiwibWF0Y2hlc0JmbFN0YXRpYyIsIm1hdGNoZXNCZmxEeW5hbWljIiwiY3VyQXMiLCJhc05vU2xhc2giLCJhc05vU2xhc2hMb2NhbGUiLCJfdGhpc19fYmZsX3MiLCJoYXMiLCJfdGhpc19fYmZsX3MxIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsInNwbGl0IiwiaSIsImN1cnJlbnRQYXJ0Iiwiam9pbiIsIl90aGlzX19iZmxfZCIsImlzTG9jYWxVUkwiLCJpc1F1ZXJ5VXBkYXRpbmciLCJfYmZsIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImRpZE5hdmlnYXRlIiwiX3RoaXNfbG9jYWxlcyIsImRldGVjdGVkRG9tYWluIiwiZG9tYWluIiwiYXNOb0Jhc2VQYXRoIiwiaHR0cCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwic2Nyb2xsIiwicm91dGVQcm9wcyIsIl9pbkZsaWdodFJvdXRlIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsImxvY2FsZUNoYW5nZSIsIm9ubHlBSGFzaENoYW5nZSIsInNjcm9sbFRvSGFzaCIsInNldCIsInBhcnNlZCIsIl90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUiLCJfX2FwcFJvdXRlciIsInVybElzTmV3IiwicGFyc2VkQXNQYXRobmFtZSIsImlzTWlkZGxld2FyZVJld3JpdGUiLCJpc01pZGRsZXdhcmVNYXRjaCIsInJld3JpdGVzUmVzdWx0IiwicCIsImV4dGVybmFsRGVzdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJtaXNzaW5nUGFyYW1zIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsIm9wdGlvbmFsIiwiY29uc29sZSIsIndhcm4iLCJvbWl0IiwiaXNFcnJvclJvdXRlIiwiZ2V0Um91dGVJbmZvIiwicm91dGVJbmZvIiwiY2xlYW5lZFBhcnNlZFBhdGhuYW1lIiwiZm9yRWFjaCIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50IiwidW5zdGFibGVfc2NyaXB0TG9hZGVyIiwic2NyaXB0cyIsImNvbmNhdCIsInNjcmlwdCIsImhhbmRsZUNsaWVudFNjcmlwdExvYWQiLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwicGFyc2VkSHJlZiIsIl9fTl9QUkVWSUVXIiwiZmV0Y2hDb21wb25lbnQiLCJub3RGb3VuZFJvdXRlIiwiaXNOb3RGb3VuZCIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyIsInN0YXR1c0NvZGUiLCJfcm91dGVJbmZvX3Byb3BzIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsIl9yb3V0ZUluZm9fcm91dGUiLCJzaG91bGRTY3JvbGwiLCJfb3B0aW9uc19zY3JvbGwiLCJyZXNldFNjcm9sbCIsInVwY29taW5nU2Nyb2xsU3RhdGUiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEiLCJfcm91dGVJbmZvX3Byb3BzMSIsImNhblNraXBVcGRhdGluZyIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYXNoUmVnZXgiLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwiZ2V0SW5pdGlhbFByb3BzIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJyZXF1ZXN0ZWRSb3V0ZSIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwiX2RhdGFfZWZmZWN0IiwiX2RhdGFfZWZmZWN0MSIsIl9kYXRhX2VmZmVjdDIiLCJyZXNvbHZlZFJvdXRlIiwiaXNBUElSb3V0ZSIsInJlcyIsIm1vZCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwiX2RhdGFfcmVzcG9uc2UiLCJzaG91bGRGZXRjaERhdGEiLCJfZ2V0RGF0YSIsImZldGNoZWQiLCJnZXRQcm9wZXJFcnJvciIsImNiIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJzY3JvbGxUbyIsInJhd0hhc2giLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXRobmFtZSIsIm9yaWdpbmFsUGF0aG5hbWUiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJsb2FkUGFnZSIsImNvbXBvbmVudFJlc3VsdCIsImZuIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});